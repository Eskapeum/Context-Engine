/**
 * Universal Context Engine - Context Generator
 *
 * Generates UCE.md - the universal context file for any AI assistant.
 *
 * @module generator
 */

import * as fs from 'fs';
import * as path from 'path';
import type { ProjectIndex, FileIndex, CodeSymbol, DependencyEdge } from './indexer.js';

// ============================================================================
// TYPES
// ============================================================================

/**
 * Configuration for context generation
 */
export interface GeneratorConfig {
  /** Project root directory */
  projectRoot: string;
  /** Project index */
  index: ProjectIndex;
  /** Maximum tokens to target */
  maxTokens: number;
  /** Whether to include file contents */
  includeFileContents: boolean;
  /** Priority files to always include */
  priorityFiles: string[];
}

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Group files by directory
 */
function groupByDirectory(files: Record<string, FileIndex>): Record<string, FileIndex[]> {
  const groups: Record<string, FileIndex[]> = {};

  for (const fileIndex of Object.values(files)) {
    const dir = path.dirname(fileIndex.path);
    if (!groups[dir]) groups[dir] = [];
    groups[dir].push(fileIndex);
  }

  return groups;
}

/**
 * Build ASCII file tree
 */
function buildFileTree(files: string[]): string {
  const tree: Record<string, any> = {};

  for (const file of files) {
    const parts = file.split('/');
    let current = tree;
    for (const part of parts) {
      if (!current[part]) current[part] = {};
      current = current[part];
    }
  }

  function render(node: Record<string, any>, prefix: string = ''): string {
    const entries = Object.entries(node).sort(([a], [b]) => {
      const aIsDir = Object.keys(node[a]).length > 0;
      const bIsDir = Object.keys(node[b]).length > 0;
      if (aIsDir !== bIsDir) return aIsDir ? -1 : 1;
      return a.localeCompare(b);
    });

    let result = '';
    entries.forEach(([key, value], index) => {
      const isLast = index === entries.length - 1;
      const connector = isLast ? '└── ' : '├── ';
      const extension = isLast ? '    ' : '│   ';
      const isDir = Object.keys(value).length > 0;

      result += `${prefix}${connector}${key}${isDir ? '/' : ''}\n`;
      if (isDir) {
        result += render(value, prefix + extension);
      }
    });

    return result;
  }

  return render(tree);
}

/**
 * Format symbol for display
 */
function formatSymbol(sym: CodeSymbol): string {
  let str = sym.name;

  if (sym.kind === 'function') {
    const params = sym.params?.join(', ') || '';
    str = `${sym.async ? 'async ' : ''}${sym.name}(${params})`;
    if (sym.returnType) str += `: ${sym.returnType}`;
  }

  return str;
}

/**
 * Format dependency graph as ASCII
 */
function formatDependencyGraph(deps: DependencyEdge[]): string {
  if (deps.length === 0) return 'No dependencies detected.';

  // Group by source
  const bySource: Record<string, string[]> = {};
  for (const dep of deps) {
    if (!bySource[dep.from]) bySource[dep.from] = [];
    bySource[dep.from].push(dep.to);
  }

  let result = '';
  for (const [from, targets] of Object.entries(bySource)) {
    result += `${from}\n`;
    targets.forEach((to, i) => {
      const isLast = i === targets.length - 1;
      result += `  ${isLast ? '└──' : '├──'} ${to}\n`;
    });
  }

  return result;
}

// ============================================================================
// GENERATOR
// ============================================================================

/**
 * Generate UCE.md - the universal context file for any AI assistant
 */
export function generateUceMd(config: GeneratorConfig): string {
  const { index } = config;

  const fileList = Object.keys(index.files).sort();
  const fileTree = buildFileTree(fileList);

  // Group files by directory with descriptions
  const byDir = groupByDirectory(index.files);

  // Get key exports
  const allSymbols = Object.values(index.files).flatMap((f) =>
    f.symbols.map((s) => ({ ...s, file: f.path }))
  );

  const exportedClasses = allSymbols.filter((s) => s.kind === 'class' && s.exported);
  const exportedFunctions = allSymbols.filter((s) => s.kind === 'function' && s.exported);
  const exportedInterfaces = allSymbols.filter((s) => s.kind === 'interface' && s.exported);
  const exportedTypes = allSymbols.filter((s) => s.kind === 'type' && s.exported);

  let md = `# ${index.projectName} - Universal Context

> Generated by Universal Context Engine (UCE) v${index.uceVersion}
> This file provides AI assistants with complete project context.

## Project Overview

| Metric | Value |
|--------|-------|
| Files | ${index.totalFiles} |
| Symbols | ${index.totalSymbols} |
| Languages | ${Object.keys(index.languageStats).join(', ')} |
| Entry Points | ${index.entryPoints.length} |

## Architecture

\`\`\`
${fileTree}
\`\`\`

## Entry Points

${index.entryPoints.map((ep) => `- \`${ep}\``).join('\n') || 'No entry points detected.'}

## Module Overview

`;

  for (const [dir, files] of Object.entries(byDir)) {
    md += `### ${dir}/\n\n`;
    for (const file of files) {
      const desc = file.description ? ` - ${file.description}` : '';
      const symCount = file.symbols.length;
      const exported = file.symbols.filter((s) => s.exported).length;
      md += `- **${path.basename(file.path)}**${desc} (${symCount} symbols, ${exported} exported)\n`;
    }
    md += '\n';
  }

  md += `## Public API

`;

  if (exportedClasses.length > 0) {
    md += `### Classes\n\n`;
    md += '| Class | Location | Description |\n';
    md += '|-------|----------|-------------|\n';
    for (const cls of exportedClasses.slice(0, 20)) {
      const loc = `${(cls as any).file}:${cls.line}`;
      md += `| \`${cls.name}\` | ${loc} | ${cls.docstring || '-'} |\n`;
    }
    if (exportedClasses.length > 20) {
      md += `| ... | ${exportedClasses.length - 20} more | |\n`;
    }
    md += '\n';
  }

  if (exportedInterfaces.length > 0) {
    md += `### Interfaces\n\n`;
    md += '| Interface | Location |\n';
    md += '|-----------|----------|\n';
    for (const iface of exportedInterfaces.slice(0, 20)) {
      md += `| \`${iface.name}\` | ${(iface as any).file}:${iface.line} |\n`;
    }
    if (exportedInterfaces.length > 20) {
      md += `| ... | ${exportedInterfaces.length - 20} more |\n`;
    }
    md += '\n';
  }

  if (exportedTypes.length > 0) {
    md += `### Types\n\n`;
    md += '| Type | Location |\n';
    md += '|------|----------|\n';
    for (const t of exportedTypes.slice(0, 20)) {
      md += `| \`${t.name}\` | ${(t as any).file}:${t.line} |\n`;
    }
    if (exportedTypes.length > 20) {
      md += `| ... | ${exportedTypes.length - 20} more |\n`;
    }
    md += '\n';
  }

  if (exportedFunctions.length > 0) {
    md += `### Functions\n\n`;
    md += '| Function | Location |\n';
    md += '|----------|----------|\n';
    for (const fn of exportedFunctions.slice(0, 20)) {
      md += `| \`${formatSymbol(fn)}\` | ${(fn as any).file}:${fn.line} |\n`;
    }
    if (exportedFunctions.length > 20) {
      md += `| ... | ${exportedFunctions.length - 20} more |\n`;
    }
    md += '\n';
  }

  md += `## Dependencies

\`\`\`
${formatDependencyGraph(index.dependencies.slice(0, 50))}
\`\`\`

${index.dependencies.length > 50 ? `*... and ${index.dependencies.length - 50} more dependency edges*` : ''}

## Language Statistics

| Language | Files | Symbols |
|----------|-------|---------|
${Object.entries(index.languageStats)
  .map(([lang, stats]) => `| ${lang} | ${stats.files} | ${stats.symbols} |`)
  .join('\n')}

## Development Guidelines

1. **Follow existing patterns** - Check similar files before implementing
2. **Maintain type safety** - Use TypeScript types throughout
3. **Check dependencies** - Understand file relationships before changes
4. **Use existing utilities** - Don't reinvent what's already built

## Quick Commands

\`\`\`bash
# Re-index the project
npx uce index

# Watch for changes
npx uce watch

# Search the codebase
npx uce query "search term"

# Start MCP server
npx uce serve
\`\`\`

---
*Auto-generated by [Universal Context Engine](https://github.com/Eskapeum/Context-Engine) v${index.uceVersion}*
*Commit this file to share context with your team and AI assistants.*
`;

  return md;
}

// ============================================================================
// MAIN GENERATOR CLASS
// ============================================================================

/**
 * Generates UCE.md - the universal context file for AI coding assistants
 *
 * @example
 * ```ts
 * const generator = new ContextGenerator({
 *   projectRoot: '/path/to/project',
 *   index: projectIndex,
 * });
 * generator.generate();
 * ```
 */
export class ContextGenerator {
  private config: GeneratorConfig;

  constructor(config: Partial<GeneratorConfig> & { projectRoot: string; index: ProjectIndex }) {
    this.config = {
      projectRoot: config.projectRoot,
      index: config.index,
      maxTokens: config.maxTokens || 50000,
      includeFileContents: config.includeFileContents ?? false,
      priorityFiles: config.priorityFiles || [],
    };
  }

  /**
   * Generate UCE.md
   */
  public generateAll(): void {
    const { projectRoot } = this.config;
    const uceMd = generateUceMd(this.config);
    fs.writeFileSync(path.join(projectRoot, 'UCE.md'), uceMd);
  }

  /**
   * Generate and return UCE.md content without writing to file
   */
  public generate(): string {
    return generateUceMd(this.config);
  }
}

export default ContextGenerator;
