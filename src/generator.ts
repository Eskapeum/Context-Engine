/**
 * Universal Context Engine - Context Generator
 *
 * Generates tool-specific context files from the project index.
 * Creates UCE.md, CONTEXT.md, CLAUDE.md, .cursorrules, and copilot-instructions.md
 *
 * @module generator
 */

import * as fs from 'fs';
import * as path from 'path';
import type { ProjectIndex, FileIndex, CodeSymbol, DependencyEdge } from './indexer.js';

// ============================================================================
// TYPES
// ============================================================================

/**
 * Configuration for context generation
 */
export interface GeneratorConfig {
  /** Project root directory */
  projectRoot: string;
  /** Project index */
  index: ProjectIndex;
  /** Maximum tokens to target */
  maxTokens: number;
  /** Whether to include file contents */
  includeFileContents: boolean;
  /** Priority files to always include */
  priorityFiles: string[];
}

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Group files by directory
 */
function groupByDirectory(files: Record<string, FileIndex>): Record<string, FileIndex[]> {
  const groups: Record<string, FileIndex[]> = {};

  for (const fileIndex of Object.values(files)) {
    const dir = path.dirname(fileIndex.path);
    if (!groups[dir]) groups[dir] = [];
    groups[dir].push(fileIndex);
  }

  return groups;
}

/**
 * Build ASCII file tree
 */
function buildFileTree(files: string[]): string {
  const tree: Record<string, any> = {};

  for (const file of files) {
    const parts = file.split('/');
    let current = tree;
    for (const part of parts) {
      if (!current[part]) current[part] = {};
      current = current[part];
    }
  }

  function render(node: Record<string, any>, prefix: string = ''): string {
    const entries = Object.entries(node).sort(([a], [b]) => {
      const aIsDir = Object.keys(node[a]).length > 0;
      const bIsDir = Object.keys(node[b]).length > 0;
      if (aIsDir !== bIsDir) return aIsDir ? -1 : 1;
      return a.localeCompare(b);
    });

    let result = '';
    entries.forEach(([key, value], index) => {
      const isLast = index === entries.length - 1;
      const connector = isLast ? '└── ' : '├── ';
      const extension = isLast ? '    ' : '│   ';
      const isDir = Object.keys(value).length > 0;

      result += `${prefix}${connector}${key}${isDir ? '/' : ''}\n`;
      if (isDir) {
        result += render(value, prefix + extension);
      }
    });

    return result;
  }

  return render(tree);
}

/**
 * Format symbol for display
 */
function formatSymbol(sym: CodeSymbol): string {
  let str = sym.name;

  if (sym.kind === 'function') {
    const params = sym.params?.join(', ') || '';
    str = `${sym.async ? 'async ' : ''}${sym.name}(${params})`;
    if (sym.returnType) str += `: ${sym.returnType}`;
  }

  return str;
}

/**
 * Format dependency graph as ASCII
 */
function formatDependencyGraph(deps: DependencyEdge[]): string {
  if (deps.length === 0) return 'No dependencies detected.';

  // Group by source
  const bySource: Record<string, string[]> = {};
  for (const dep of deps) {
    if (!bySource[dep.from]) bySource[dep.from] = [];
    bySource[dep.from].push(dep.to);
  }

  let result = '';
  for (const [from, targets] of Object.entries(bySource)) {
    result += `${from}\n`;
    targets.forEach((to, i) => {
      const isLast = i === targets.length - 1;
      result += `  ${isLast ? '└──' : '├──'} ${to}\n`;
    });
  }

  return result;
}

// ============================================================================
// GENERATORS
// ============================================================================

/**
 * Generate generic CONTEXT.md
 */
export function generateContextMd(config: GeneratorConfig): string {
  const { index } = config;

  const fileList = Object.keys(index.files).sort();
  const fileTree = buildFileTree(fileList);

  // Group symbols by kind
  const symbolsByKind: Record<string, CodeSymbol[]> = {};
  for (const file of Object.values(index.files)) {
    for (const sym of file.symbols) {
      if (!symbolsByKind[sym.kind]) symbolsByKind[sym.kind] = [];
      symbolsByKind[sym.kind].push({ ...sym, parent: file.path } as CodeSymbol & { parent: string });
    }
  }

  let md = `# ${index.projectName} - Project Context

> Auto-generated by Universal Context Engine (UCE) v${index.uceVersion}
> Indexed at: ${index.indexedAt}

## Overview

- **Files**: ${index.totalFiles}
- **Symbols**: ${index.totalSymbols}
- **Languages**: ${Object.keys(index.languageStats).join(', ')}

## Project Structure

\`\`\`
${fileTree}
\`\`\`

## Entry Points

${index.entryPoints.map((ep) => `- \`${ep}\``).join('\n') || 'No entry points detected.'}

## Key Symbols

`;

  // Add key exported symbols
  const kinds = ['class', 'interface', 'function', 'type', 'constant'] as const;
  for (const kind of kinds) {
    const symbols = symbolsByKind[kind]?.filter((s) => s.exported) || [];
    if (symbols.length > 0) {
      md += `### ${kind.charAt(0).toUpperCase() + kind.slice(1)}es\n\n`;
      for (const sym of symbols.slice(0, 20)) {
        md += `- \`${formatSymbol(sym)}\` (${(sym as any).parent}:${sym.line})\n`;
      }
      if (symbols.length > 20) {
        md += `- ... and ${symbols.length - 20} more\n`;
      }
      md += '\n';
    }
  }

  md += `## Dependencies

\`\`\`
${formatDependencyGraph(index.dependencies.slice(0, 50))}
\`\`\`

${index.dependencies.length > 50 ? `... and ${index.dependencies.length - 50} more dependency edges` : ''}

## Language Statistics

| Language | Files | Symbols |
|----------|-------|---------|
${Object.entries(index.languageStats)
  .map(([lang, stats]) => `| ${lang} | ${stats.files} | ${stats.symbols} |`)
  .join('\n')}

---
*This file is auto-generated by UCM. Commit it to share context with your team.*
`;

  return md;
}

/**
 * Generate Claude Code specific CLAUDE.md
 */
export function generateClaudeMd(config: GeneratorConfig): string {
  const { index } = config;

  const fileList = Object.keys(index.files).sort();
  const fileTree = buildFileTree(fileList);

  // Group files by directory with descriptions
  const byDir = groupByDirectory(index.files);

  let md = `# Claude Code Context - ${index.projectName}

> This file helps Claude Code understand your project structure.
> Generated by Universal Context Engine (UCE) v${index.uceVersion}

## Project Overview

This is a ${Object.keys(index.languageStats).join('/')} project with ${index.totalFiles} files and ${index.totalSymbols} symbols.

## File Structure

\`\`\`
${fileTree}
\`\`\`

## Directory Descriptions

`;

  for (const [dir, files] of Object.entries(byDir)) {
    md += `### ${dir}/

`;
    for (const file of files) {
      const desc = file.description ? ` - ${file.description}` : '';
      const symCount = file.symbols.length;
      md += `- **${path.basename(file.path)}**${desc} (${symCount} symbols)\n`;
    }
    md += '\n';
  }

  md += `## Key APIs

`;

  // List key exported functions and classes
  const allSymbols = Object.values(index.files).flatMap((f) =>
    f.symbols.map((s) => ({ ...s, file: f.path }))
  );

  const exportedClasses = allSymbols.filter((s) => s.kind === 'class' && s.exported);
  const exportedFunctions = allSymbols.filter((s) => s.kind === 'function' && s.exported);
  const exportedInterfaces = allSymbols.filter((s) => s.kind === 'interface' && s.exported);

  if (exportedClasses.length > 0) {
    md += `### Classes\n\n`;
    for (const cls of exportedClasses.slice(0, 15)) {
      md += `- \`${cls.name}\` in \`${(cls as any).file}\`\n`;
    }
    md += '\n';
  }

  if (exportedInterfaces.length > 0) {
    md += `### Interfaces\n\n`;
    for (const iface of exportedInterfaces.slice(0, 15)) {
      md += `- \`${iface.name}\` in \`${(iface as any).file}\`\n`;
    }
    md += '\n';
  }

  if (exportedFunctions.length > 0) {
    md += `### Functions\n\n`;
    for (const fn of exportedFunctions.slice(0, 15)) {
      md += `- \`${formatSymbol(fn)}\` in \`${(fn as any).file}\`\n`;
    }
    md += '\n';
  }

  md += `## Development Guidelines

1. **Maintain existing patterns** - Look at similar files before making changes
2. **Check dependencies** - Use the dependency graph above to understand impact
3. **Type safety** - Maintain TypeScript types where used
4. **Test coverage** - Add tests for new functionality

## Quick Commands

\`\`\`bash
# Re-index after major changes
npx uce index

# Watch mode (auto-update context)
npx uce watch

# Query the codebase
npx uce query "term"
\`\`\`

---
*This file is auto-generated by Universal Context Engine (UCE) v${index.uceVersion}*
*Commit this file to keep your project context up to date*
`;

  return md;
}

/**
 * Generate Cursor IDE .cursorrules
 */
export function generateCursorRules(config: GeneratorConfig): string {
  const { index } = config;

  const fileList = Object.keys(index.files).sort();

  // Get key exports
  const allSymbols = Object.values(index.files).flatMap((f) =>
    f.symbols.filter((s) => s.exported).map((s) => ({ ...s, file: f.path }))
  );

  let rules = `# Cursor Rules for ${index.projectName}
# Generated by Universal Context Engine (UCE) v${index.uceVersion}

# Project Type
This is a ${Object.keys(index.languageStats).join('/')} project.

# Key Files
${fileList.slice(0, 30).map((f) => `# - ${f}`).join('\n')}
${fileList.length > 30 ? `# ... and ${fileList.length - 30} more files` : ''}

# Entry Points
${index.entryPoints.map((ep) => `# - ${ep}`).join('\n') || '# None detected'}

# Key Exports
`;

  // List important exports
  const classes = allSymbols.filter((s) => s.kind === 'class');
  const interfaces = allSymbols.filter((s) => s.kind === 'interface');
  const functions = allSymbols.filter((s) => s.kind === 'function');

  if (classes.length > 0) {
    rules += `# Classes: ${classes
      .slice(0, 10)
      .map((c) => c.name)
      .join(', ')}\n`;
  }
  if (interfaces.length > 0) {
    rules += `# Interfaces: ${interfaces
      .slice(0, 10)
      .map((i) => i.name)
      .join(', ')}\n`;
  }
  if (functions.length > 0) {
    rules += `# Functions: ${functions
      .slice(0, 10)
      .map((f) => f.name)
      .join(', ')}\n`;
  }

  rules += `
# Guidelines
# - Follow existing code patterns in this project
# - Maintain type safety
# - Check imports before adding new dependencies
# - Use existing utilities where available

# Dependencies (${index.dependencies.length} edges)
${index.dependencies
  .slice(0, 20)
  .map((d) => `# ${d.from} -> ${d.to}`)
  .join('\n')}

# Language Stats
${Object.entries(index.languageStats)
  .map(([lang, stats]) => `# ${lang}: ${stats.files} files, ${stats.symbols} symbols`)
  .join('\n')}
`;

  return rules;
}

/**
 * Generate universal UCE.md - the primary context file for any AI assistant
 */
export function generateUceMd(config: GeneratorConfig): string {
  const { index } = config;

  const fileList = Object.keys(index.files).sort();
  const fileTree = buildFileTree(fileList);

  // Group files by directory with descriptions
  const byDir = groupByDirectory(index.files);

  // Get key exports
  const allSymbols = Object.values(index.files).flatMap((f) =>
    f.symbols.map((s) => ({ ...s, file: f.path }))
  );

  const exportedClasses = allSymbols.filter((s) => s.kind === 'class' && s.exported);
  const exportedFunctions = allSymbols.filter((s) => s.kind === 'function' && s.exported);
  const exportedInterfaces = allSymbols.filter((s) => s.kind === 'interface' && s.exported);
  const exportedTypes = allSymbols.filter((s) => s.kind === 'type' && s.exported);

  let md = `# ${index.projectName} - Universal Context

> Generated by Universal Context Engine (UCE) v${index.uceVersion}
> This file provides AI assistants with complete project context.

## Project Overview

| Metric | Value |
|--------|-------|
| Files | ${index.totalFiles} |
| Symbols | ${index.totalSymbols} |
| Languages | ${Object.keys(index.languageStats).join(', ')} |
| Entry Points | ${index.entryPoints.length} |

## Architecture

\`\`\`
${fileTree}
\`\`\`

## Entry Points

${index.entryPoints.map((ep) => `- \`${ep}\``).join('\n') || 'No entry points detected.'}

## Module Overview

`;

  for (const [dir, files] of Object.entries(byDir)) {
    md += `### ${dir}/\n\n`;
    for (const file of files) {
      const desc = file.description ? ` - ${file.description}` : '';
      const symCount = file.symbols.length;
      const exported = file.symbols.filter((s) => s.exported).length;
      md += `- **${path.basename(file.path)}**${desc} (${symCount} symbols, ${exported} exported)\n`;
    }
    md += '\n';
  }

  md += `## Public API

`;

  if (exportedClasses.length > 0) {
    md += `### Classes\n\n`;
    md += '| Class | Location | Description |\n';
    md += '|-------|----------|-------------|\n';
    for (const cls of exportedClasses.slice(0, 20)) {
      const loc = `${(cls as any).file}:${cls.line}`;
      md += `| \`${cls.name}\` | ${loc} | ${cls.docstring || '-'} |\n`;
    }
    if (exportedClasses.length > 20) {
      md += `| ... | ${exportedClasses.length - 20} more | |\n`;
    }
    md += '\n';
  }

  if (exportedInterfaces.length > 0) {
    md += `### Interfaces\n\n`;
    md += '| Interface | Location |\n';
    md += '|-----------|----------|\n';
    for (const iface of exportedInterfaces.slice(0, 20)) {
      md += `| \`${iface.name}\` | ${(iface as any).file}:${iface.line} |\n`;
    }
    if (exportedInterfaces.length > 20) {
      md += `| ... | ${exportedInterfaces.length - 20} more |\n`;
    }
    md += '\n';
  }

  if (exportedTypes.length > 0) {
    md += `### Types\n\n`;
    md += '| Type | Location |\n';
    md += '|------|----------|\n';
    for (const t of exportedTypes.slice(0, 20)) {
      md += `| \`${t.name}\` | ${(t as any).file}:${t.line} |\n`;
    }
    if (exportedTypes.length > 20) {
      md += `| ... | ${exportedTypes.length - 20} more |\n`;
    }
    md += '\n';
  }

  if (exportedFunctions.length > 0) {
    md += `### Functions\n\n`;
    md += '| Function | Location |\n';
    md += '|----------|----------|\n';
    for (const fn of exportedFunctions.slice(0, 20)) {
      md += `| \`${formatSymbol(fn)}\` | ${(fn as any).file}:${fn.line} |\n`;
    }
    if (exportedFunctions.length > 20) {
      md += `| ... | ${exportedFunctions.length - 20} more |\n`;
    }
    md += '\n';
  }

  md += `## Dependencies

\`\`\`
${formatDependencyGraph(index.dependencies.slice(0, 50))}
\`\`\`

${index.dependencies.length > 50 ? `*... and ${index.dependencies.length - 50} more dependency edges*` : ''}

## Language Statistics

| Language | Files | Symbols |
|----------|-------|---------|
${Object.entries(index.languageStats)
  .map(([lang, stats]) => `| ${lang} | ${stats.files} | ${stats.symbols} |`)
  .join('\n')}

## Development Guidelines

1. **Follow existing patterns** - Check similar files before implementing
2. **Maintain type safety** - Use TypeScript types throughout
3. **Check dependencies** - Understand file relationships before changes
4. **Use existing utilities** - Don't reinvent what's already built

## Quick Commands

\`\`\`bash
# Re-index the project
npx uce index

# Watch for changes
npx uce watch

# Search the codebase
npx uce search "query"

# Start MCP server
npx uce serve
\`\`\`

---
*Auto-generated by [Universal Context Engine](https://github.com/Eskapeum/Context-Memory) v${index.uceVersion}*
*Commit this file to share context with your team and AI assistants.*
`;

  return md;
}

/**
 * Generate GitHub Copilot instructions
 */
export function generateCopilotInstructions(config: GeneratorConfig): string {
  const { index } = config;

  const fileList = Object.keys(index.files).sort();
  const fileTree = buildFileTree(fileList);

  // Get key exports
  const allSymbols = Object.values(index.files).flatMap((f) =>
    f.symbols.filter((s) => s.exported).map((s) => ({ ...s, file: f.path }))
  );

  let md = `# GitHub Copilot Instructions for ${index.projectName}

> Generated by Universal Context Engine (UCE) v${index.uceVersion}

## Project Context

This is a ${Object.keys(index.languageStats).join('/')} project with the following structure:

\`\`\`
${fileTree}
\`\`\`

## Key Components

`;

  // List key components
  const classes = allSymbols.filter((s) => s.kind === 'class');
  const interfaces = allSymbols.filter((s) => s.kind === 'interface');
  const functions = allSymbols.filter((s) => s.kind === 'function');

  if (classes.length > 0) {
    md += `### Classes\n`;
    for (const cls of classes.slice(0, 10)) {
      md += `- \`${cls.name}\` (${(cls as any).file})\n`;
    }
    md += '\n';
  }

  if (interfaces.length > 0) {
    md += `### Interfaces\n`;
    for (const iface of interfaces.slice(0, 10)) {
      md += `- \`${iface.name}\` (${(iface as any).file})\n`;
    }
    md += '\n';
  }

  if (functions.length > 0) {
    md += `### Key Functions\n`;
    for (const fn of functions.slice(0, 10)) {
      md += `- \`${fn.name}\` (${(fn as any).file})\n`;
    }
    md += '\n';
  }

  md += `## Coding Guidelines

When working in this codebase:

1. **Follow existing patterns** - Check similar files before implementing new features
2. **Type safety** - Maintain strong typing throughout
3. **Import existing utilities** - Don't reinvent what already exists:
${allSymbols
  .slice(0, 10)
  .map((s) => `   - \`${s.name}\` from \`${(s as any).file}\``)
  .join('\n')}

4. **Check dependencies** - Be aware of how files depend on each other

## Entry Points

${index.entryPoints.map((ep) => `- \`${ep}\``).join('\n') || 'None detected'}

---
*Auto-generated by UCM*
`;

  return md;
}

// ============================================================================
// MAIN GENERATOR CLASS
// ============================================================================

/**
 * Generates context files for AI coding assistants
 *
 * @example
 * ```ts
 * const generator = new ContextGenerator({
 *   projectRoot: '/path/to/project',
 *   index: projectIndex,
 * });
 * generator.generateAll();
 * ```
 */
export class ContextGenerator {
  private config: GeneratorConfig;

  constructor(config: Partial<GeneratorConfig> & { projectRoot: string; index: ProjectIndex }) {
    this.config = {
      projectRoot: config.projectRoot,
      index: config.index,
      maxTokens: config.maxTokens || 50000,
      includeFileContents: config.includeFileContents ?? false,
      priorityFiles: config.priorityFiles || [],
    };
  }

  /**
   * Generate all context files
   */
  public generateAll(): void {
    const { projectRoot } = this.config;

    // Generate UCE.md (primary universal context file)
    const uceMd = generateUceMd(this.config);
    fs.writeFileSync(path.join(projectRoot, 'UCE.md'), uceMd);

    // Generate CONTEXT.md
    const contextMd = generateContextMd(this.config);
    fs.writeFileSync(path.join(projectRoot, 'CONTEXT.md'), contextMd);

    // Generate CLAUDE.md
    const claudeMd = generateClaudeMd(this.config);
    fs.writeFileSync(path.join(projectRoot, 'CLAUDE.md'), claudeMd);

    // Generate .cursorrules
    const cursorRules = generateCursorRules(this.config);
    fs.writeFileSync(path.join(projectRoot, '.cursorrules'), cursorRules);

    // Generate .github/copilot-instructions.md
    const githubDir = path.join(projectRoot, '.github');
    if (!fs.existsSync(githubDir)) {
      fs.mkdirSync(githubDir, { recursive: true });
    }
    const copilotInstructions = generateCopilotInstructions(this.config);
    fs.writeFileSync(path.join(githubDir, 'copilot-instructions.md'), copilotInstructions);
  }

  /**
   * Generate a specific context file
   */
  public generate(target: 'uce' | 'context' | 'claude' | 'cursor' | 'copilot'): string {
    switch (target) {
      case 'uce':
        return generateUceMd(this.config);
      case 'context':
        return generateContextMd(this.config);
      case 'claude':
        return generateClaudeMd(this.config);
      case 'cursor':
        return generateCursorRules(this.config);
      case 'copilot':
        return generateCopilotInstructions(this.config);
    }
  }
}

export default ContextGenerator;
